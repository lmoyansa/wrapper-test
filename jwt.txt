<?xml version="1.0" encoding="UTF-8"?>
<mule xmlns:ee="http://www.mulesoft.org/schema/mule/ee/core"
	xmlns:scripting="http://www.mulesoft.org/schema/mule/scripting" xmlns:doc="http://www.mulesoft.org/schema/mule/documentation"
	xmlns="http://www.mulesoft.org/schema/mule/core"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:http-policy="http://www.mulesoft.org/schema/mule/http-policy"
      xmlns:http-transform="http://www.mulesoft.org/schema/mule/http-policy-transform"
      xsi:schemaLocation="
http://www.mulesoft.org/schema/mule/ee/core http://www.mulesoft.org/schema/mule/ee/core/current/mule-ee.xsd 
http://www.mulesoft.org/schema/mule/scripting http://www.mulesoft.org/schema/mule/scripting/current/mule-scripting.xsd http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd
               http://www.mulesoft.org/schema/mule/http-policy http://www.mulesoft.org/schema/mule/http-policy/current/mule-http-policy.xsd
               http://www.mulesoft.org/schema/mule/http-policy-transform http://www.mulesoft.org/schema/mule/http-policy-transform/current/mule-http-policy-transform.xsd">


    <http-policy:proxy name="{{{policyId}}}-custom-policy">
        <http-policy:source>
         <try>
				<scripting:execute engine="groovy" doc:name="Execute" doc:id="96fe5edd-5ed2-4404-9f71-8f1e4ca2e0c0" >
					<scripting:code>
import groovy.json.JsonSlurper;
import java.io.IOException;
import java.security.*;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64.*;
import java.util.Date;
import java.util.TimeZone;
import Java.time.*;
import java.text.*;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.Mac;
import javax.crypto.Cipher; 

//========================= FUNTIONS ==================    
def validateTokenTime = { exp ->;
			
    String aux = exp;
    int milis = 1000;
                                                
    long timeNow = System.currentTimeMillis();				
    DateFormat simple = new SimpleDateFormat("dd MMM yyyy HH:mm:ss:SSS Z"); 
    simple.setTimeZone(TimeZone.getTimeZone("UTC"));
                        
    Date resultNow = new Date(timeNow); 
    Date resultExp = new Date(exp*milis);
 	
    if (resultNow.after(resultExp)) {
		return "KO";
    } else {
		return "OK";
    }
	
}

String WINDOWS_LINE_SEPARATOR = "\r\n";
String LINUX_LINE_SEPARATOR = "\n";

def stripBeginEnd = { pem ->;

	String stripped = pem.replace("-----BEGIN PUBLIC KEY-----", "");
	stripped = stripped.replace("-----END PUBLIC KEY-----", "");
	stripped = stripped.replace(WINDOWS_LINE_SEPARATOR, "");
	stripped = stripped.replace(LINUX_LINE_SEPARATOR, "");

	return stripped.trim();
}

//====================== END FUNTIONS ==================   

def secret;
String publicKeyString;

try {
	secret = '${SECRET_KEY}'
} catch(Exception e) {
}

try {
	publicKeyString = '${PUBLIC_KEY}'
} catch(Exception e) {
}

try {
	publicKeyStringISAM = '${PUBLIC_KEY_ISAM}'
} catch(Exception e) {
}

if(secret.equals("")) {
	if(publicKeyString.equals("")) {
		return 510
	}	
}

try {
	audienceValidation = '${AUDIENCE_VALIDATION}'
} catch(Exception e) {
}

try {
	if (audienceValidation == "true"){
		audience = '${AUDIENCE}'
	}
} catch(Exception e) {
}

//========================= split and decode token ==================    
				
def authHeader;
def tokenParts;
String result= "";

try {	
	authHeader = attributes.headers.Authorization;
	tokenParts = authHeader.replaceAll(&quot;Bearer &quot;, &quot;&quot;).split(&quot;\\.&quot;);
} catch(Exception e) {
	return "401";
}

Long exp;
def objectPayload;

try {
	def bytesPayload = java.util.Base64.getDecoder().decode(tokenParts[1]);
	def tokenPayload = new String(bytesPayload, &quot;UTF-8&quot;);
	
	def jsonSlurperPayload = new JsonSlurper();
	objectPayload = jsonSlurperPayload.parseText(tokenPayload);
						
	exp = objectPayload.exp;	

} catch(Exception e) {
	log.info("Exception: "+e) 
	return "401";
}

def alg;
result = "500";
def tokenHeaders = "";
def payload = "";

try{	
//========================= select token parts to select algorithm  ==================    
	def bytes = java.util.Base64.getDecoder().decode(tokenParts[0]);
	tokenHeaders = new String(bytes, &quot;UTF-8&quot;);
	def jsonSlurper = new JsonSlurper();
	def object = jsonSlurper.parseText(tokenHeaders);
	alg = object.alg;

	def bytesp = java.util.Base64.getDecoder().decode(tokenParts[1]);
	payload = new String(bytesp, &quot;UTF-8&quot;);

} catch(Exception e){
	log.info("Exception: "+e);
	return "401";
}	

if (validateTokenTime(exp) == &quot;OK&quot;) {
	try{
		if (alg == &quot;HS256&quot;) { 
			//========================= Algoritmo de cifrado HS256  ==================    
			
			def algorithm=&quot;HmacSHA256&quot;
			Mac sha256_HMAC = Mac.getInstance(algorithm);
			SecretKeySpec secret_key = new SecretKeySpec(secret.getBytes(), algorithm);
			sha256_HMAC.init(secret_key);
			byte[] signature = sha256_HMAC.doFinal ( ( tokenParts[0] + '.' + tokenParts[1]).getBytes(&quot;US-ASCII&quot;));
			def signature2 = Base64.getUrlEncoder().withoutPadding().encodeToString(signature);
			def signatureResult = &quot;Signature is not correct&quot;
			if (signature2 == tokenParts[2]){
				signatureResult = &quot;Signature is correct&quot;
				result = '200';
			} else {
				return '401';
			}
				
		} else if(alg == &quot;RS256&quot;) {
			//========================= Algoritmo de cifrado RS256  ==================    
			
			String stripped = "";//stripBeginEnd(publicKeyString);

			Base64.Decoder decoder = Base64.getDecoder();		
			
			String algorithm = "SHA256withRSA";		
			byte[] keyBytes = null;//decoder.decode(stripped);

			X509EncodedKeySpec pubKeySpec;
			KeyFactory keyFactory;
			PublicKey publicKey;
			Signature signature;
			RSAPublicKey pubKeyObject;

			if (audienceValidation == "true"){
				if (payload.contains("pocisam")) {
					aud = objectPayload.audiencias;
					stripped = stripBeginEnd(publicKeyStringISAM);
				} else {
					aud = objectPayload.aud;
					stripped = stripBeginEnd(publicKeyString);
				}

				if (!aud.contains(audience)) {
					System.out.println "Las audiencia no está incluida en la lista del token" 
					return 600;
				} else {
					System.out.println "Audiencia válida"
				}
			}
				
			try {
			
				keyBytes = decoder.decode(stripped);

				pubKeySpec = new X509EncodedKeySpec(keyBytes); 
				keyFactory = KeyFactory.getInstance("RSA");
				publicKey = keyFactory.generatePublic(pubKeySpec);        
					
				signature = Signature.getInstance(algorithm);                
				signature.initVerify(publicKey);                
				signature.update((tokenParts[0] + '.' + tokenParts[1]).getBytes());
				
			} catch (Exception e) {

				keyBytes = decoder.decode(stripped);

				pubKeyObject = PKCS1ToSubjectPublicKeyInfo.decodePKCS1PublicKey(keyBytes);

				signature = Signature.getInstance(algorithm);                
				signature.initVerify(pubKeyObject);                
				signature.update((tokenParts[0] + '.' + tokenParts[1]).getBytes());

			}
			
				
			String data = new String (tokenParts[2]);
			byte[] dataBytes = Base64.getUrlDecoder().decode(data.getBytes("UTF-8"));
					
			if (signature.verify(dataBytes)) {
				result = "200";
			} else {
				result = "401";
			}		

		}

	} catch(Exception e){
		return '401';
	}
	return result;
} else {
	return 401;
}



class PKCS1ToSubjectPublicKeyInfo {

    private static final int SEQUENCE_TAG = 0x30;
    private static final int BIT_STRING_TAG = 0x03;
    private static final byte[] NO_UNUSED_BITS = [ 0x00 ] as byte[];
    private static final byte[] RSA_ALGORITHM_IDENTIFIER_SEQUENCE = [(byte) 0x30, (byte) 0x0d, 
    		(byte) 0x06, (byte) 0x09, (byte) 0x2a, (byte) 0x86, (byte) 0x48, (byte) 0x86, (byte) 0xf7, 
    		(byte) 0x0d, (byte) 0x01, (byte) 0x01, (byte) 0x01, (byte) 0x05, (byte) 0x00];


    public static RSAPublicKey decodePKCS1PublicKey(byte[] pkcs1PublicKeyEncoding)
            throws NoSuchAlgorithmException, InvalidKeySpecException
    {
        byte[] subjectPublicKeyInfo2 = createSubjectPublicKeyInfoEncoding(pkcs1PublicKeyEncoding);
        KeyFactory rsaKeyFactory = KeyFactory.getInstance("RSA");
        RSAPublicKey generatePublic = (RSAPublicKey) rsaKeyFactory.generatePublic(new X509EncodedKeySpec(subjectPublicKeyInfo2));
        return generatePublic;
    }

    public static byte[] createSubjectPublicKeyInfoEncoding(byte[] pkcs1PublicKeyEncoding) {
        byte[] subjectPublicKeyBitString = createDEREncoding(BIT_STRING_TAG, concat(NO_UNUSED_BITS, pkcs1PublicKeyEncoding));
        byte[] subjectPublicKeyInfoValue = concat(RSA_ALGORITHM_IDENTIFIER_SEQUENCE, subjectPublicKeyBitString);
        byte[] subjectPublicKeyInfoSequence = createDEREncoding(SEQUENCE_TAG, subjectPublicKeyInfoValue);

        return subjectPublicKeyInfoSequence;
    }

    private static byte[] concat(byte[] ... bas) {
        int len = 0;
        for (int i = 0; i &lt; bas.length; i++)
        {
            len += bas[i].length;
        }

        byte[] buf = new byte[len];
        int off = 0;
        for (int i = 0; i &lt; bas.length; i++)
        {
            System.arraycopy(bas[i], 0, buf, off, bas[i].length);
            off += bas[i].length;
        }

        return buf;
    }

    private static byte[] createDEREncoding(int tag, byte[] value) {
        if (tag &lt; 0 || tag &gt;= 0xFF)
        {
            throw new IllegalArgumentException("Currently only single byte tags supported");
        }

        byte[] lengthEncoding = createDERLengthEncoding(value.length);

        int size = 1 + lengthEncoding.length + value.length;
        byte[] derEncodingBuf = new byte[size];

        int off = 0;
        derEncodingBuf[off++] = (byte) tag;
        System.arraycopy(lengthEncoding, 0, derEncodingBuf, off, lengthEncoding.length);
        off += lengthEncoding.length;
        System.arraycopy(value, 0, derEncodingBuf, off, value.length);

        return derEncodingBuf;
    }   

    private static byte[] createDERLengthEncoding(int size) {
        if (size &lt;= 0x7F)
        {
            // single byte length encoding
            return [ (byte) size ] as byte[];
        }
        else if (size &lt;= 0xFF)
        {
            // double byte length encoding
            return [ (byte) 0x81, (byte) size ] as byte[];
        }
        else if (size &lt;= 0xFFFF)
        {
            // triple byte length encoding
            return [ (byte) 0x82, (byte) (size &gt;&gt; Byte.SIZE), (byte) size ] as byte[];
        }

        throw new IllegalArgumentException("size too large, only up to 64KiB length encoding supported: " + size);
    }
    
}

					</scripting:code>
				</scripting:execute>
				
				
            <set-variable value="#[payload]" doc:name="Set Variable" doc:id="3a35570a-210d-463e-88ea-2dfea1019132" variableName="code"/>   
			<choice doc:name="Choice" doc:id="c8164cf8-d5ca-40e8-a49b-c843575e7152" >
				<when expression="#[vars.code as String == '200']">
					 <http-policy:execute-next/>     
				</when>
				<when expression="#[vars.code as String == '401']">
					 <http-policy:execute-next/>     
            			<http-transform:set-response statusCode="401">
                            <http-transform:body>#[
output application/json
---
{
	code: "401",
	message: "Unauthorized",
	moreInformation: {
		description : "Invalid JWT",
		link: "www.correos.es"
	}
}
                                ]</http-transform:body>
                        </http-transform:set-response>						
				</when>
				<when expression="#[vars.code as String == '600']">
					 <http-policy:execute-next/>     
            			<http-transform:set-response statusCode="401">
                            <http-transform:body>#[
output application/json
---
{
	code: "401",
	message: "Unauthorized",
	moreInformation: {
		description : "Audience is not present on the token",
		link: "www.correos.es"
	}
}
                                ]</http-transform:body>
                        </http-transform:set-response>						
				</when>
				
				<when expression="#[vars.code as String == '510']">
					 <http-policy:execute-next/>     
            			<http-transform:set-response statusCode="510">
                            <http-transform:body>#[
output application/json
---
{
	code: "510",
	message: "Not Extended",
	moreInformation: {
		description : "Validation codes (public and secret) were not correctly defined",
		link: "www.correos.es"
	}
}
                                ]</http-transform:body>
                        </http-transform:set-response>						
				</when>
				
				<otherwise >
				<http-transform:set-response statusCode="500">
                            <http-transform:body>#[
output application/json
---
{
	code: "500",
	message: "Internal Error Server",
	moreInformation: {
		description : "Policy error",
		link: "www.correos.es"
	}
}
                                ]</http-transform:body>
                        </http-transform:set-response>		
				</otherwise>
			</choice>  
				<error-handler>
                    
                    <on-error-propagate type="APIKIT:NOT_FOUND">
						<http-transform:set-response statusCode="404">
                            <http-transform:body>#[
output application/json
---
{
	code: "404",
	message: "Resource not found",
	moreInformation: {
		description: "Resource not found",
		link: "www.correos.es"
	}
}
                            ]</http-transform:body>
                        </http-transform:set-response>				
					</on-error-propagate>
					<on-error-propagate type="APIKIT:METHOD_NOT_ALLOWED">
						<http-transform:set-response statusCode="404">
                            <http-transform:body>#[
output application/json
---
{
	code: "405",
	message: "Method not allowed",
	moreInformation: {
		description: error.description  as String default "",
		link: "www.correos.es"
	}
}
                            ]</http-transform:body>
                        </http-transform:set-response>				
					</on-error-propagate>

					<on-error-propagate type="APIKIT:BAD_REQUEST">
							<http-transform:set-response statusCode="400">
								<http-transform:body>#[
output application/json
---
{
	code: "400",
	message: "Bad request",
	moreInformation: {
		description: error.description  as String default "",
		link: "www.correos.es"
	}
}
                           	]</http-transform:body>
                       	</http-transform:set-response>	
					</on-error-propagate>
					<on-error-propagate type="APIKIT:NOT_ACCEPTABLE">
							<http-transform:set-response statusCode="406">
								<http-transform:body>#[
output application/json
---
{
	code: "406",
	message: "Unsupported media type",
	moreInformation: {
		description: error.description  as String default "",
		link: "www.correos.es"
	}
}
                           	]</http-transform:body>
                       	</http-transform:set-response>	
					</on-error-propagate>
					<on-error-propagate type="APIKIT:UNSUPPORTED_MEDIA_TYPE">
							<http-transform:set-response statusCode="415">
								<http-transform:body>#[
output application/json
---
{
	code: "415",
	message: "Unsupported media type",
	moreInformation: {
		description: error.description  as String default "",
		link: "www.correos.es"
	}
}
                           	]</http-transform:body>
                       	</http-transform:set-response>	
					</on-error-propagate>
					<on-error-propagate type="APIKIT:NOT_IMPLEMENTED">
							<http-transform:set-response statusCode="501">
								<http-transform:body>#[
output application/json
---
{
	code: "501",
	message: "Not Implemented",
	moreInformation: {
		description: error.description  as String default "",
		link: "www.correos.es"
	}
}
                           	]</http-transform:body>
                       	</http-transform:set-response>	
					</on-error-propagate>
					<on-error-propagate enableNotifications="true" logException="true" doc:name="On Error Propagate" doc:id="979febcc-60f6-4cf2-a72b-bffa969d9016" type="HTTP:CONNECTIVITY">
							<http-transform:set-response statusCode="500">
								<http-transform:body>#[
output application/json
---
{
	code: "500",
	message: "Internal Server Error",
	moreInformation: {
		description: error.description  as String default "",
		link: "www.correos.es"
	}
}
                           	]</http-transform:body>
                       	</http-transform:set-response>	
					</on-error-propagate>	

                </error-handler>
                
            </try>
        </http-policy:source>
    </http-policy:proxy>
</mule>